{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "\n",
    "# We will use a class called my trie node\n",
    "class MyTrieNode:\n",
    "    # Initialize some fields \n",
    "  \n",
    "    def __init__(self, isRootNode):\n",
    "        #The initialization below is just a suggestion.\n",
    "        #Change it as you will.\n",
    "        # But do not change the signature of the constructor.\n",
    "        self.isRoot = isRootNode\n",
    "        self.isWordEnd = False # is this node a word ending node\n",
    "        self.isRoot = False # is this a root node\n",
    "        self.count = 0 # frequency count \n",
    "        self.next = {} # Dictionary mapping each character from a-z to \n",
    "                       # the child node if any corresponding to that character.\n",
    "\n",
    "\n",
    "    def addWord(self,w):\n",
    "        assert(len(w) > 0)\n",
    "        \n",
    "        curr = self\n",
    "       \n",
    "        for letter in w:\n",
    "            char_in_curr = False\n",
    "            for key,value in curr.next.items():  #iterate through letters in current node's child's dictionary\n",
    "                if key == letter:\n",
    "                    curr = curr.next[key]  #set current node to node corresponding to letter\n",
    "                    char_in_curr = True  \n",
    "                    break\n",
    "            if char_in_curr == False:\n",
    "                curr.next[letter] = MyTrieNode(False)\n",
    "                curr = curr.next[letter]\n",
    "        \n",
    "        curr.iswordEnd = True\n",
    "        curr.count += 1\n",
    "        \n",
    "        return\n",
    "\n",
    "    def lookupWord(self,w):\n",
    "\n",
    "        curr = self\n",
    "        char_in_curr = False\n",
    "        \n",
    "        for letter in w:   \n",
    "            char_in_curr = False\n",
    "            for key,value in curr.next.items():\n",
    "                if key == letter:\n",
    "                    curr = curr.next[key]\n",
    "                    char_in_curr = True \n",
    "                    break\n",
    "            if char_in_curr == False:\n",
    "                return 0\n",
    "        \n",
    "        return curr.count \n",
    "    \n",
    "    \n",
    "    def acHelper(self,w):\n",
    "\n",
    "        curr = self\n",
    "        char_in_curr = False\n",
    "        \n",
    "        for letter in w:   \n",
    "            char_in_curr = False\n",
    "            for key,value in curr.next.items():\n",
    "                if key == letter:\n",
    "                    curr = curr.next[key]\n",
    "                    char_in_curr = True \n",
    "                    break\n",
    "            if char_in_curr == False:\n",
    "                return {}\n",
    "        \n",
    "        return curr\n",
    "    \n",
    "    def recursethru(self, node, w, tempstring = \"\"):\n",
    "            \n",
    "            for key2, value in node.next.items():\n",
    "                print(\"We are in recursive fn\", \"key = \", key2)\n",
    "                tempstring += key2                    #add our extra letter to word \n",
    "                if node.isWordEnd:\n",
    "                    print(\"Finished first word\", w+tempstring, node.count)\n",
    "                    return (w+tempstring, node.count)\n",
    "                self.recursethru(node.next[key2],w,tempstring)          #set current node to node corresponding w key\n",
    "     \n",
    "\n",
    "    def autoComplete(self,w):\n",
    "        #Returns possible list of autocompletions of the word w\n",
    "        #Returns a list of pairs (s,j) denoting that\n",
    "        #         word s occurs with frequency j\n",
    "        \n",
    "        \n",
    "        results_list = []\n",
    "        curr = self.acHelper(w)  #start at the node where the word \"w\" ends\n",
    "        \n",
    "        if curr.iswordEnd == True:\n",
    "            results_list.append(tuple((w,curr.count)))\n",
    "        print(results_list)\n",
    "        for key,value in curr.next.items():\n",
    "            print(\"We are in autocomplete fn\", \"key = \", key)\n",
    "            results_list.append(tuple((self.recursethru(curr.next[key],w+key,tempstring = \"\"))))  #nonetype object is non iterable\n",
    "\n",
    "        return results_list    \n",
    "            "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
